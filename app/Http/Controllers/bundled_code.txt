

=== File: NotificationController.php ===

<?php

namespace App\Http\Controllers;

use App\Models\Notification;
use App\Services\NotificationService;
use Illuminate\Http\Request;
use Illuminate\View\View;

class NotificationController extends Controller
{
    protected NotificationService $notificationService;
    
    public function __construct(NotificationService $notificationService)
    {
        $this->notificationService = $notificationService;
    }
    
    public function index(): View
    {
        $notifications = Notification::where('user_id', auth()->id())
            ->orderBy('created_at', 'desc')
            ->paginate(20);
            
        return view('livewire.pages.notifications.index', compact('notifications'));
    }
    
    public function markAsRead(Notification $notification)
    {
        // Ensure the notification belongs to the user
        if ($notification->user_id !== auth()->id()) {
            return back()->with('error', 'Unauthorized action.');
        }
        
        $this->notificationService->markAsRead($notification);
        
        return back()->with('success', 'Notification marked as read.');
    }
    
    public function markAllAsRead()
    {
        $user = auth()->user();
        
        Notification::where('user_id', $user->id)
            ->whereNull('read_at')
            ->update(['read_at' => now()]);
            
        return back()->with('success', 'All notifications marked as read.');
    }
}

=== File: Controller.php ===

<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}


=== File: SavingsWalletController.php ===

<?php

namespace App\Http\Controllers;

use App\Models\SavingsWallet;
use App\Models\Trip;
use App\Services\SavingsService;
use Illuminate\Http\Request;
use Illuminate\View\View;

class SavingsWalletController extends Controller
{
    protected SavingsService $savingsService;
    
    public function __construct(SavingsService $savingsService)
    {
        $this->middleware('tripmember');
        $this->savingsService = $savingsService;
    }
    
    public function show(Trip $trip): View
    {
        $wallet = $trip->savingsWallet;
        $transactions = $this->savingsService->getTransactionHistory($wallet, 10);
        $suggestedContribution = $this->savingsService->calculateSuggestedContribution($wallet);
        
        return view('livewire.pages.savings.wallet', compact('trip', 'wallet', 'transactions', 'suggestedContribution'));
    }
    
    public function edit(Trip $trip): View
    {
        $wallet = $trip->savingsWallet;
        
        return view('livewire.pages.savings.edit', compact('trip', 'wallet'));
    }
    
    public function update(Request $request, Trip $trip)
    {
        $wallet = $trip->savingsWallet;
        
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'target_amount' => 'required|numeric|min:0',
            'target_date' => 'required|date|after_or_equal:today',
            'contribution_frequency' => 'required|in:weekly,monthly',
        ]);
        
        $this->savingsService->updateWalletSettings($wallet, $validated);
        
        return redirect()->route('trips.savings.show', $trip)
            ->with('success', 'Savings wallet updated successfully!');
    }
    
    public function contribute(Request $request, Trip $trip)
    {
        $wallet = $trip->savingsWallet;
        
        $validated = $request->validate([
            'amount' => 'required|numeric|min:1',
            'payment_method' => 'nullable|string|max:50',
        ]);
        
        $this->savingsService->deposit($wallet, auth()->id(), $validated['amount'], $validated['payment_method'] ?? null);
        
        return back()->with('success', 'Contribution added successfully!');
    }
    
    public function withdraw(Request $request, Trip $trip)
    {
        $wallet = $trip->savingsWallet;
        
        $validated = $request->validate([
            'amount' => 'required|numeric|min:1|max:' . $wallet->current_amount,
        ]);
        
        try {
            $this->savingsService->withdraw($wallet, auth()->id(), $validated['amount']);
            return back()->with('success', 'Withdrawal processed successfully!');
        } catch (\Exception $e) {
            return back()->with('error', $e->getMessage());
        }
    }
    
    public function transactions(Trip $trip): View
    {
        $wallet = $trip->savingsWallet;
        $transactions = $this->savingsService->getTransactionHistory($wallet, 50);
        
        return view('livewire.pages.savings.transactions', compact('trip', 'wallet', 'transactions'));
    }
}

=== File: DashboardController.php ===

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\View\View;

class DashboardController extends Controller
{
    /**
     * Display the dashboard with static data
     * No authentication check required - accessible to all users
     */
    public function index(Request $request): View
    {
        // Static demo data to match React dashboard
        $userBalance = 1250.75;
        $targetAmount = 2500.00;
        $completionPercentage = ($userBalance / $targetAmount) * 100;
        
        $upcomingTrips = [
            (object)[
                'id' => 1,
                'title' => 'Bali Adventure',
                'destination' => 'Bali, Indonesia',
                'start_date' => now()->addMonths(2),
                'end_date' => now()->addMonths(2)->addDays(10),
                'progress' => 50,
                'members' => 5,
                'savingsWallet' => (object)[
                    'current_amount' => 1250.75,
                    'target_amount' => 2500.00,
                    'progress_percentage' => 50
                ]
            ],
            (object)[
                'id' => 2,
                'title' => 'Safari Weekend',
                'destination' => 'Maasai Mara, Kenya',
                'start_date' => now()->addMonth(),
                'end_date' => now()->addMonth()->addDays(3),
                'progress' => 75,
                'members' => 3,
                'savingsWallet' => (object)[
                    'current_amount' => 450.00,
                    'target_amount' => 600.00,
                    'progress_percentage' => 75
                ]
            ]
        ];
        
        $recentActivities = [
            (object)[
                'id' => 1,
                'type' => 'contribution',
                'amount' => 200.00,
                'date' => now()->subDays(4),
                'trip' => 'Bali Adventure'
            ],
            (object)[
                'id' => 2,
                'type' => 'contribution',
                'amount' => 150.00,
                'date' => now()->subDays(7),
                'trip' => 'Safari Weekend'
            ],
            (object)[
                'id' => 3,
                'type' => 'friend_joined',
                'user' => 'Sarah Johnson',
                'date' => now()->subDays(10),
                'trip' => 'Bali Adventure'
            ],
            (object)[
                'id' => 4,
                'type' => 'itinerary_update',
                'date' => now()->subDays(15),
                'trip' => 'Safari Weekend'
            ]
        ];
        
        $invitations = [
            (object)[
                'id' => 1,
                'title' => 'European Tour',
                'invited_by' => 'Mike Williams',
                'expires_at' => now()->addMonth(),
            ]
        ];
        
        $stats = [
            'total_saved' => $userBalance,
            'trips_planned' => 4,
            'trips_completed' => 2,
            'trips_upcoming' => 2,
            'friends_onboarded' => 8,
            'monthly_growth_percentage' => 12
        ];
        
        $wallet = [
            'balance' => $userBalance,
            'target_amount' => $targetAmount,
            'progress_percentage' => $completionPercentage,
            'monthly_growth_percentage' => 12
        ];
        
        return view('livewire.pages.dashboard', compact(
            'upcomingTrips',
            'recentActivities',
            'invitations',
            'stats',
            'wallet'
        ));
    }
}

=== File: ItineraryController.php ===

<?php

namespace App\Http\Controllers;

use App\Models\Activity;
use App\Models\Itinerary;
use App\Models\Trip;
use Illuminate\Http\Request;
use Illuminate\View\View;

class ItineraryController extends Controller
{
    public function __construct()
    {
        $this->middleware('tripmember');
    }
    
    /**
     * Display the itinerary planner for a trip.
     */
    public function index(Trip $trip): View
    {
        // Load itineraries with their activities, ordered by day number
        $itineraries = $trip->itineraries()
            ->orderBy('day_number')
            ->with('activities')
            ->get();
            
        return view('livewire.pages.itinerary.planner', compact('trip', 'itineraries'));
    }
    
    /**
     * Display the itinerary for a specific day.
     */
    public function show(Trip $trip, Itinerary $itinerary): View
    {
        // Load the itinerary with its activities
        $itinerary->load('activities');
        
        // Get the previous and next itineraries for navigation
        $prevItinerary = $trip->itineraries()
            ->where('day_number', '<', $itinerary->day_number)
            ->orderBy('day_number', 'desc')
            ->first();
            
        $nextItinerary = $trip->itineraries()
            ->where('day_number', '>', $itinerary->day_number)
            ->orderBy('day_number')
            ->first();
        
        return view('livewire.pages.itinerary.day', compact('trip', 'itinerary', 'prevItinerary', 'nextItinerary'));
    }
    
    /**
     * Update the specified itinerary.
     */
    public function update(Request $request, Trip $trip, Itinerary $itinerary)
    {
        $validated = $request->validate([
            'title' => 'required|string|max:255',
            'description' => 'nullable|string',
        ]);
        
        $itinerary->update($validated);
        
        return back()->with('success', 'Itinerary updated successfully!');
    }
    
    /**
     * Show the form for creating a new activity.
     */
    public function createActivity(Trip $trip, Itinerary $itinerary): View
    {
        $activityTypes = [
            'Cultural', 'Beach', 'Adventure', 'Food', 
            'Shopping', 'Nightlife', 'Relaxation', 'Sightseeing'
        ];
        
        return view('livewire.pages.itinerary.activity.create', compact('trip', 'itinerary', 'activityTypes'));
    }
    
    /**
     * Show the form for editing the specified activity.
     */
    public function editActivity(Trip $trip, Itinerary $itinerary, Activity $activity): View
    {
        // Check if the activity belongs to this itinerary
        if ($activity->itinerary_id !== $itinerary->id) {
            abort(404);
        }
        
        $activityTypes = [
            'Cultural', 'Beach', 'Adventure', 'Food', 
            'Shopping', 'Nightlife', 'Relaxation', 'Sightseeing'
        ];
        
        return view('livewire.pages.itinerary.activity.edit', compact('trip', 'itinerary', 'activity', 'activityTypes'));
    }
}

=== File: ActivityController.php ===

<?php

namespace App\Http\Controllers;

use App\Models\Activity;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class ActivityController extends Controller
{
    /**
     * Display a listing of activities for a trip.
     */
    public function index(Request $request)
    {
        $tripId = $request->input('trip_id');
        $dayNumber = $request->input('day');
        
        $activities = Activity::whereHas('itinerary', function($query) use ($tripId, $dayNumber) {
            $query->where('trip_id', $tripId);
            
            if ($dayNumber) {
                $query->where('day_number', $dayNumber);
            }
        })->get();
        
        return response()->json(['activities' => $activities]);
    }

    /**
     * Store a newly created activity in storage.
     */
    public function store(Request $request)
    {
        $request->validate([
            'itinerary_id' => 'required|exists:itineraries,id',
            'title' => 'required|string|max:255',
            'location' => 'nullable|string|max:255',
            'start_time' => 'nullable|date_format:H:i',
            'end_time' => 'nullable|date_format:H:i|after:start_time',
            'cost' => 'nullable|numeric|min:0',
        ]);
        
        $activity = Activity::create($request->all());
        
        return response()->json(['activity' => $activity, 'message' => 'Activity created successfully']);
    }

    /**
     * Get activity suggestion by ID.
     */
    public function getSuggestion($id)
    {
        // This would typically fetch from a database, but for this example,
        // we'll return some sample data
        $suggestions = [
            1 => [
                'name' => 'Kecak Fire Dance at Uluwatu',
                'location' => 'Uluwatu Temple',
                'cost' => 15,
                'category' => 'cultural',
                'description' => 'Experience the mesmerizing traditional Balinese Kecak dance performance at sunset, with the majestic Uluwatu Temple as the backdrop.',
            ],
            2 => [
                'name' => 'Seafood Dinner at Jimbaran Bay',
                'location' => 'Jimbaran Beach',
                'cost' => 30,
                'category' => 'food',
                'description' => 'Enjoy fresh seafood grilled to perfection right on the beach, with your feet in the sand as the sun sets over the ocean.',
            ],
        ];
        
        if (isset($suggestions[$id])) {
            return response()->json(['success' => true, 'data' => $suggestions[$id]]);
        }
        
        return response()->json(['success' => false, 'message' => 'Suggestion not found'], 404);
    }
    
    /**
     * Update the specified activity in storage.
     */
    public function update(Request $request, Activity $activity)
    {
        $request->validate([
            'title' => 'sometimes|required|string|max:255',
            'location' => 'nullable|string|max:255',
            'start_time' => 'nullable|date_format:H:i',
            'end_time' => 'nullable|date_format:H:i|after:start_time',
            'cost' => 'nullable|numeric|min:0',
        ]);
        
        $activity->update($request->all());
        
        return response()->json(['activity' => $activity, 'message' => 'Activity updated successfully']);
    }

    /**
     * Remove the specified activity from storage.
     */
    public function destroy(Activity $activity)
    {
        $activity->delete();
        
        return response()->json(['message' => 'Activity deleted successfully']);
    }
}

=== File: bundled_code.txt ===



=== File: NotificationController.php ===

<?php

namespace App\Http\Controllers;

use App\Models\Notification;
use App\Services\NotificationService;
use Illuminate\Http\Request;
use Illuminate\View\View;

class NotificationController extends Controller
{
    protected NotificationService $notificationService;
    
    public function __construct(NotificationService $notificationService)
    {
        $this->notificationService = $notificationService;
    }
    
    public function index(): View
    {
        $notifications = Notification::where('user_id', auth()->id())
            ->orderBy('created_at', 'desc')
            ->paginate(20);
            
        return view('livewire.pages.notifications.index', compact('notifications'));
    }
    
    public function markAsRead(Notification $notification)
    {
        // Ensure the notification belongs to the user
        if ($notification->user_id !== auth()->id()) {
            return back()->with('error', 'Unauthorized action.');
        }
        
        $this->notificationService->markAsRead($notification);
        
        return back()->with('success', 'Notification marked as read.');
    }
    
    public function markAllAsRead()
    {
        $user = auth()->user();
        
        Notification::where('user_id', $user->id)
            ->whereNull('read_at')
            ->update(['read_at' => now()]);
            
        return back()->with('success', 'All notifications marked as read.');
    }
}

=== File: Controller.php ===

<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}


=== File: SavingsWalletController.php ===

<?php

namespace App\Http\Controllers;

use App\Models\SavingsWallet;
use App\Models\Trip;
use App\Services\SavingsService;
use Illuminate\Http\Request;
use Illuminate\View\View;

class SavingsWalletController extends Controller
{
    protected SavingsService $savingsService;
    
    public function __construct(SavingsService $savingsService)
    {
        $this->middleware('tripmember');
        $this->savingsService = $savingsService;
    }
    
    public function show(Trip $trip): View
    {
        $wallet = $trip->savingsWallet;
        $transactions = $this->savingsService->getTransactionHistory($wallet, 10);
        $suggestedContribution = $this->savingsService->calculateSuggestedContribution($wallet);
        
        return view('livewire.pages.savings.wallet', compact('trip', 'wallet', 'transactions', 'suggestedContribution'));
    }
    
    public function edit(Trip $trip): View
    {
        $wallet = $trip->savingsWallet;
        
        return view('livewire.pages.savings.edit', compact('trip', 'wallet'));
    }
    
    public function update(Request $request, Trip $trip)
    {
        $wallet = $trip->savingsWallet;
        
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'target_amount' => 'required|numeric|min:0',
            'target_date' => 'required|date|after_or_equal:today',
            'contribution_frequency' => 'required|in:weekly,monthly',
        ]);
        
        $this->savingsService->updateWalletSettings($wallet, $validated);
        
        return redirect()->route('trips.savings.show', $trip)
            ->with('success', 'Savings wallet updated successfully!');
    }
    
    public function contribute(Request $request, Trip $trip)
    {
        $wallet = $trip->savingsWallet;
        
        $validated = $request->validate([
            'amount' => 'required|numeric|min:1',
            'payment_method' => 'nullable|string|max:50',
        ]);
        
        $this->savingsService->deposit($wallet, auth()->id(), $validated['amount'], $validated['payment_method'] ?? null);
        
        return back()->with('success', 'Contribution added successfully!');
    }
    
    public function withdraw(Request $request, Trip $trip)
    {
        $wallet = $trip->savingsWallet;
        
        $validated = $request->validate([
            'amount' => 'required|numeric|min:1|max:' . $wallet->current_amount,
        ]);
        
        try {
            $this->savingsService->withdraw($wallet, auth()->id(), $validated['amount']);
            return back()->with('success', 'Withdrawal processed successfully!');
        } catch (\Exception $e) {
            return back()->with('error', $e->getMessage());
        }
    }
    
    public function transactions(Trip $trip): View
    {
        $wallet = $trip->savingsWallet;
        $transactions = $this->savingsService->getTransactionHistory($wallet, 50);
        
        return view('livewire.pages.savings.transactions', compact('trip', 'wallet', 'transactions'));
    }
}

=== File: DashboardController.php ===

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\View\View;

class DashboardController extends Controller
{
    /**
     * Display the dashboard with static data
     * No authentication check required - accessible to all users
     */
    public function index(Request $request): View
    {
        // Static demo data to match React dashboard
        $userBalance = 1250.75;
        $targetAmount = 2500.00;
        $completionPercentage = ($userBalance / $targetAmount) * 100;
        
        $upcomingTrips = [
            (object)[
                'id' => 1,
                'title' => 'Bali Adventure',
                'destination' => 'Bali, Indonesia',
                'start_date' => now()->addMonths(2),
                'end_date' => now()->addMonths(2)->addDays(10),
                'progress' => 50,
                'members' => 5,
                'savingsWallet' => (object)[
                    'current_amount' => 1250.75,
                    'target_amount' => 2500.00,
                    'progress_percentage' => 50
                ]
            ],
            (object)[
                'id' => 2,
                'title' => 'Safari Weekend',
                'destination' => 'Maasai Mara, Kenya',
                'start_date' => now()->addMonth(),
                'end_date' => now()->addMonth()->addDays(3),
                'progress' => 75,
                'members' => 3,
                'savingsWallet' => (object)[
                    'current_amount' => 450.00,
                    'target_amount' => 600.00,
                    'progress_percentage' => 75
                ]
            ]
        ];
        
        $recentActivities = [
            (object)[
                'id' => 1,
                'type' => 'contribution',
                'amount' => 200.00,
                'date' => now()->subDays(4),
                'trip' => 'Bali Adventure'
            ],
            (object)[
                'id' => 2,
                'type' => 'contribution',
                'amount' => 150.00,
                'date' => now()->subDays(7),
                'trip' => 'Safari Weekend'
            ],
            (object)[
                'id' => 3,
                'type' => 'friend_joined',
                'user' => 'Sarah Johnson',
                'date' => now()->subDays(10),
                'trip' => 'Bali Adventure'
            ],
            (object)[
                'id' => 4,
                'type' => 'itinerary_update',
                'date' => now()->subDays(15),
                'trip' => 'Safari Weekend'
            ]
        ];
        
        $invitations = [
            (object)[
                'id' => 1,
                'title' => 'European Tour',
                'invited_by' => 'Mike Williams',
                'expires_at' => now()->addMonth(),
            ]
        ];
        
        $stats = [
            'total_saved' => $userBalance,
            'trips_planned' => 4,
            'trips_completed' => 2,
            'trips_upcoming' => 2,
            'friends_onboarded' => 8,
            'monthly_growth_percentage' => 12
        ];
        
        $wallet = [
            'balance' => $userBalance,
            'target_amount' => $targetAmount,
            'progress_percentage' => $completionPercentage,
            'monthly_growth_percentage' => 12
        ];
        
        return view('livewire.pages.dashboard', compact(
            'upcomingTrips',
            'recentActivities',
            'invitations',
            'stats',
            'wallet'
        ));
    }
}

=== File: TripController.php ===

<?php

namespace App\Http\Controllers;

use App\Models\Trip;
use App\Models\TripTemplate;
use App\Models\Destination;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class TripController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        $user = Auth::user();
        $trips = Trip::where('creator_id', $user->id)
            ->orWhereHas('members', function($query) use ($user) {
                $query->where('user_id', $user->id);
            })
            ->with(['savingsWallet', 'creator', 'members', 'tripTemplate'])
            ->orderBy('start_date', 'asc')
            ->get();
        
        return view('trips.index', compact('trips'));
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        return view('trips.create');
    }

    /**
     * Store a new resource in storage.
     */
    public function store(Request $request)
    {
        // Validation
        $validated = $request->validate([
            'planning_type' => 'required|in:self_planned,pre_planned',
            'title' => 'required|string|max:255',
            'destination' => 'required|string|max:255',
            'start_date' => 'required|date',
            'end_date' => 'required|date|after_or_equal:start_date',
            'budget' => 'required|numeric|min:0',
            'trip_template_id' => 'nullable|exists:trip_templates,id',
        ]);
        
        // Create trip
        $trip = Trip::create([
            'creator_id' => Auth::id(),
            'planning_type' => $validated['planning_type'],
            'title' => $validated['title'],
            'description' => $request->description ?? null,
            'destination' => $validated['destination'],
            'start_date' => $validated['start_date'],
            'end_date' => $validated['end_date'],
            'budget' => $validated['budget'],
            'status' => 'planning',
            'trip_template_id' => $validated['trip_template_id'] ?? null,
        ]);
        
        // For pre-planned trips, create itineraries from template
        if ($trip->planning_type === 'pre_planned' && $trip->trip_template_id) {
            $trip->createItinerariesFromTemplate();
        } 
        // Create default itinerary if none exists for self-planned trips
        else if ($trip->planning_type === 'self_planned') {
            $startDate = $trip->start_date;
            $endDate = $trip->end_date;
            $dayCount = $startDate->diffInDays($endDate) + 1; // Include start and end day
            
            for ($day = 1; $day <= $dayCount; $day++) {
                $date = clone $startDate;
                $date->addDays($day - 1);
                
                $trip->itineraries()->create([
                    'title' => "Day {$day}: {$trip->destination}",
                    'description' => "Day {$day} activities in {$trip->destination}",
                    'day_number' => $day,
                    'date' => $date,
                ]);
            }
        }
        
        // Create savings wallet
        $trip->savingsWallet()->create([
            'name' => 'Trip to ' . $trip->destination,
            'target_amount' => $trip->budget,
            'current_amount' => 0,
            'target_date' => $trip->end_date,
            'contribution_frequency' => 'weekly'
        ]);
        
        return redirect()->route('trips.show', $trip)->with('success', 'Trip created successfully!');
    }

    /**
     * Display the specified resource.
     */
    public function show(Trip $trip)
    {
        // Check if user is authorized to view the trip
        if (!$this->userCanAccessTrip($trip)) {
            return redirect()->route('trips.index')->with('error', 'You do not have permission to view this trip.');
        }
        
        $trip->load(['creator', 'members', 'itineraries.activities', 'savingsWallet', 'tripTemplate']);
        
        return view('trips.show', compact('trip'));
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(Trip $trip)
    {
        // Check if user is authorized to edit the trip
        if (!$this->userCanAccessTrip($trip)) {
            return redirect()->route('trips.index')->with('error', 'You do not have permission to edit this trip.');
        }
        
        $trip->load(['creator', 'members', 'itineraries.activities', 'savingsWallet', 'tripTemplate']);
        
        return view('trips.edit', compact('trip'));
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, Trip $trip)
    {
        // Check if user is authorized to update the trip
        if (!$this->userCanAccessTrip($trip)) {
            return redirect()->route('trips.index')->with('error', 'You do not have permission to update this trip.');
        }
        
        // Validation
        $validated = $request->validate([
            'title' => 'required|string|max:255',
            'description' => 'nullable|string',
            'start_date' => 'required|date',
            'end_date' => 'required|date|after_or_equal:start_date',
            'budget' => 'required|numeric|min:0',
            'status' => 'nullable|in:planning,booked,in_progress,completed,cancelled',
        ]);
        
        // Update trip
        $trip->update($validated);
        
        // Update savings wallet target
        if ($trip->savingsWallet) {
            $trip->savingsWallet->update([
                'target_amount' => $validated['budget'],
                'target_date' => $validated['end_date'],
            ]);
        }
        
        return redirect()->route('trips.show', $trip)->with('success', 'Trip updated successfully!');
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(Trip $trip)
    {
        // Check if user is authorized to delete the trip
        if (Auth::id() !== $trip->creator_id) {
            return redirect()->route('trips.index')->with('error', 'You do not have permission to delete this trip.');
        }
        
        $trip->delete();
        
        return redirect()->route('trips.index')->with('success', 'Trip deleted successfully!');
    }
    
    /**
     * Browse pre-planned trip templates.
     */
    public function browseTemplates()
    {
        $destinations = Destination::has('tripTemplates')->get();
        $featuredTemplates = TripTemplate::where('is_featured', true)
            ->with('destination')
            ->take(6)
            ->get();
        
        return view('trips.browse-templates', compact('destinations', 'featuredTemplates'));
    }
    
    /**
     * Show template details.
     */
    public function showTemplate(TripTemplate $template)
    {
        $template->load(['destination', 'activities']);
        
        // Group activities by day
        $activities = $template->activities;
        $groupedActivities = [];
        
        foreach ($activities as $activity) {
            $groupedActivities[$activity->day_number][] = $activity;
        }
        
        // Sort activities by start_time for each day
        foreach ($groupedActivities as $day => $dayActivities) {
            usort($dayActivities, function($a, $b) {
                return $a->start_time <=> $b->start_time;
            });
            
            $groupedActivities[$day] = $dayActivities;
        }
        
        return view('trips.template-details', compact('template', 'groupedActivities'));
    }
    
    /**
     * Check if user can access a trip.
     */
    private function userCanAccessTrip(Trip $trip)
    {
        $user = Auth::user();
        
        // Trip creator can access
        if ($trip->creator_id === $user->id) {
            return true;
        }
        
        // Trip members can access
        $isMember = $trip->members()->where('user_id', $user->id)->exists();
        if ($isMember) {
            return true;
        }
        
        return false;
    }
}

=== File: Auth/PasswordResetLinkController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;

class PasswordResetLinkController extends Controller
{
    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'email'],
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        return $status == Password::RESET_LINK_SENT
                    ? back()->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

=== File: Auth/AuthControllers.php.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Providers\RouteServiceProvider;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use App\Models\User;

class RegisteredUserController extends Controller
{
    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'string', 'email', 'max:255', 'unique:users'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
            'terms' => ['required', 'accepted'],
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        Auth::login($user);

        return redirect(route('dashboard'));
    }
}

class AuthenticatedSessionController extends Controller
{
    /**
     * Handle an incoming authentication request.
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'string', 'email'],
            'password' => ['required', 'string'],
        ]);

        $credentials = $request->only('email', 'password');
        $remember = $request->boolean('remember');

        if (Auth::attempt($credentials, $remember)) {
            $request->session()->regenerate();

            return redirect()->intended(route('dashboard'));
        }

        return back()->withErrors([
            'email' => __('auth.failed'),
        ])->onlyInput('email');
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Auth::guard('web')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard'));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}

class PasswordResetLinkController extends Controller
{
    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'email'],
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        return $status == Password::RESET_LINK_SENT
                    ? back()->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

class NewPasswordController extends Controller
{
    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => ['required'],
            'email' => ['required', 'email'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        return $status == Password::PASSWORD_RESET
                    ? redirect()->route('login')->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

class ConfirmablePasswordController extends Controller
{
    /**
     * Confirm the user's password.
     */
    public function store(Request $request): RedirectResponse
    {
        if (! Auth::guard('web')->validate([
            'email' => $request->user()->email,
            'password' => $request->password,
        ])) {
            throw ValidationException::withMessages([
                'password' => __('auth.password'),
            ]);
        }

        $request->session()->put('auth.password_confirmed_at', time());

        return redirect()->intended(route('dashboard'));
    }
}

=== File: Auth/SocialAuthController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Exception;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Session;
use Illuminate\Support\Str;
use Laravel\Socialite\Facades\Socialite;

class SocialAuthController extends Controller
{
    /**
     * Redirect to the given provider's authentication page
     *
     * @param string $provider
     * @return mixed
     */
    public function authProviderRedirect($provider)
    {
        try {
            if (in_array($provider, ['google', 'facebook'])) {
                return Socialite::driver($provider)->redirect();
            }
            return redirect()->route('login')->with('error', 'Invalid authentication provider.');
        } catch (Exception $e) {
            Log::error('Social auth redirect error: ' . $e->getMessage());
            return redirect()->route('login')->with('error', 'Could not connect to ' . ucfirst($provider) . '. Please try again.');
        }
    }

    /**
     * Handle the callback from social authentication providers
     *
     * @param string $provider
     * @return RedirectResponse
     */
    public function socialAuthentication($provider)
    {
        try {
            if (!in_array($provider, ['google', 'facebook'])) {
                return redirect()->route('login')->with('error', 'Invalid authentication provider.');
            }
            
            $socialUser = Socialite::driver($provider)->user();
            
            // Find user by provider ID first
            $user = User::where('auth_provider_id', $socialUser->id)
                        ->where('auth_provider', $provider)
                        ->first();
            
            // If user not found by provider ID, try to find by email
            if (!$user) {
                $user = User::where('email', $socialUser->email)->first();
                
                // If user exists with the same email, update their provider details
                if ($user) {
                    $user->update([
                        'auth_provider' => $provider,
                        'auth_provider_id' => $socialUser->id,
                    ]);
                } else {
                    // Create a new user
                    $user = User::create([
                        'name' => $socialUser->name,
                        'email' => $socialUser->email,
                        'password' => Hash::make(Str::random(24)), // Generate a secure random password
                        'auth_provider_id' => $socialUser->id,
                        'auth_provider' => $provider,
                        'email_verified_at' => now(), // Social logins are considered verified
                    ]);
                    
                    // Save profile photo if available
                    if ($socialUser->avatar) {
                        $user->update([
                            'profile_photo_path' => $socialUser->avatar
                        ]);
                    }
                }
            }
            
            Auth::login($user);
            return redirect()->route('dashboard')->with('success', 'Successfully logged in!');
            
        } catch (Exception $e) {
            Log::error('Social authentication error: ' . $e->getMessage());
            return redirect()->route('login')
                ->with('error', 'Authentication failed. Please try again or use email login.');
        }
    }
}

=== File: Auth/VerifyEmailController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Providers\RouteServiceProvider;
use Illuminate\Auth\Events\Verified;
use Illuminate\Foundation\Auth\EmailVerificationRequest;
use Illuminate\Http\RedirectResponse;

class VerifyEmailController extends Controller
{
    /**
     * Mark the authenticated user's email address as verified.
     *
     * @param  \Illuminate\Foundation\Auth\EmailVerificationRequest  $request
     * @return \Illuminate\Http\RedirectResponse
     */
    public function __invoke(EmailVerificationRequest $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard').'?verified=1');
        }

        if ($request->user()->markEmailAsVerified()) {
            event(new Verified($request->user()));
        }

        return redirect()->intended(route('dashboard').'?verified=1');
    }
}

=== File: Auth/AuthenticatedSessionController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;

class AuthenticatedSessionController extends Controller
{
    /**
     * Handle an incoming authentication request.
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'string', 'email'],
            'password' => ['required', 'string'],
        ]);

        $credentials = $request->only('email', 'password');
        $remember = $request->boolean('remember');

        if (Auth::attempt($credentials, $remember)) {
            $request->session()->regenerate();

            // Log successful login
            Log::info('User logged in successfully', ['email' => $request->email]);
            
            return redirect()->intended(route('dashboard'));
        }

        // Log failed login attempt
        Log::info('Failed login attempt', ['email' => $request->email]);

        return back()->withErrors([
            'email' => __('auth.failed'),
        ])->withInput($request->only('email'));
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Auth::guard('web')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}

=== File: Auth/EmailVerificationNotificationController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard'));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}

=== File: Auth/RegisteredUserController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Providers\RouteServiceProvider;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use Illuminate\View\View;
use App\Models\User;

class RegisteredUserController extends Controller
{
    /**
     * Display the registration view.
     */
    public function create(): View
    {
        return view('auth.register');
    }

    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $validationRules = [
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'string', 'email', 'max:255', 'unique:users'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ];
        
        // Only add terms validation if it's in your form
        if ($request->has('terms')) {
            $validationRules['terms'] = ['required', 'accepted'];
        }
        
        $request->validate($validationRules);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        // Remove automatic login after registration
        // Auth::login($user); <-- Comment out or remove this line
        
        // Add a success message
        session()->flash('success', 'Registration successful! Please login to access your account.');
        
        // Redirect to login instead of dashboard
        return redirect()->route('login');
    }
}

=== File: Auth/bundled_code.txt ===



=== File: PasswordResetLinkController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;

class PasswordResetLinkController extends Controller
{
    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'email'],
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        return $status == Password::RESET_LINK_SENT
                    ? back()->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

=== File: AuthControllers.php.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Providers\RouteServiceProvider;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use App\Models\User;

class RegisteredUserController extends Controller
{
    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'string', 'email', 'max:255', 'unique:users'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
            'terms' => ['required', 'accepted'],
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        Auth::login($user);

        return redirect(route('dashboard'));
    }
}

class AuthenticatedSessionController extends Controller
{
    /**
     * Handle an incoming authentication request.
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'string', 'email'],
            'password' => ['required', 'string'],
        ]);

        $credentials = $request->only('email', 'password');
        $remember = $request->boolean('remember');

        if (Auth::attempt($credentials, $remember)) {
            $request->session()->regenerate();

            return redirect()->intended(route('dashboard'));
        }

        return back()->withErrors([
            'email' => __('auth.failed'),
        ])->onlyInput('email');
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Auth::guard('web')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard'));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}

class PasswordResetLinkController extends Controller
{
    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'email'],
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        return $status == Password::RESET_LINK_SENT
                    ? back()->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

class NewPasswordController extends Controller
{
    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => ['required'],
            'email' => ['required', 'email'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        return $status == Password::PASSWORD_RESET
                    ? redirect()->route('login')->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

class ConfirmablePasswordController extends Controller
{
    /**
     * Confirm the user's password.
     */
    public function store(Request $request): RedirectResponse
    {
        if (! Auth::guard('web')->validate([
            'email' => $request->user()->email,
            'password' => $request->password,
        ])) {
            throw ValidationException::withMessages([
                'password' => __('auth.password'),
            ]);
        }

        $request->session()->put('auth.password_confirmed_at', time());

        return redirect()->intended(route('dashboard'));
    }
}

=== File: SocialAuthController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Exception;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Session;
use Illuminate\Support\Str;
use Laravel\Socialite\Facades\Socialite;

class SocialAuthController extends Controller
{
    /**
     * Redirect to the given provider's authentication page
     *
     * @param string $provider
     * @return mixed
     */
    public function authProviderRedirect($provider)
    {
        try {
            if (in_array($provider, ['google', 'facebook'])) {
                return Socialite::driver($provider)->redirect();
            }
            return redirect()->route('login')->with('error', 'Invalid authentication provider.');
        } catch (Exception $e) {
            Log::error('Social auth redirect error: ' . $e->getMessage());
            return redirect()->route('login')->with('error', 'Could not connect to ' . ucfirst($provider) . '. Please try again.');
        }
    }

    /**
     * Handle the callback from social authentication providers
     *
     * @param string $provider
     * @return RedirectResponse
     */
    public function socialAuthentication($provider)
    {
        try {
            if (!in_array($provider, ['google', 'facebook'])) {
                return redirect()->route('login')->with('error', 'Invalid authentication provider.');
            }
            
            $socialUser = Socialite::driver($provider)->user();
            
            // Find user by provider ID first
            $user = User::where('auth_provider_id', $socialUser->id)
                        ->where('auth_provider', $provider)
                        ->first();
            
            // If user not found by provider ID, try to find by email
            if (!$user) {
                $user = User::where('email', $socialUser->email)->first();
                
                // If user exists with the same email, update their provider details
                if ($user) {
                    $user->update([
                        'auth_provider' => $provider,
                        'auth_provider_id' => $socialUser->id,
                    ]);
                } else {
                    // Create a new user
                    $user = User::create([
                        'name' => $socialUser->name,
                        'email' => $socialUser->email,
                        'password' => Hash::make(Str::random(24)), // Generate a secure random password
                        'auth_provider_id' => $socialUser->id,
                        'auth_provider' => $provider,
                        'email_verified_at' => now(), // Social logins are considered verified
                    ]);
                    
                    // Save profile photo if available
                    if ($socialUser->avatar) {
                        $user->update([
                            'profile_photo_path' => $socialUser->avatar
                        ]);
                    }
                }
            }
            
            Auth::login($user);
            return redirect()->route('dashboard')->with('success', 'Successfully logged in!');
            
        } catch (Exception $e) {
            Log::error('Social authentication error: ' . $e->getMessage());
            return redirect()->route('login')
                ->with('error', 'Authentication failed. Please try again or use email login.');
        }
    }
}

=== File: VerifyEmailController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Providers\RouteServiceProvider;
use Illuminate\Auth\Events\Verified;
use Illuminate\Foundation\Auth\EmailVerificationRequest;
use Illuminate\Http\RedirectResponse;

class VerifyEmailController extends Controller
{
    /**
     * Mark the authenticated user's email address as verified.
     *
     * @param  \Illuminate\Foundation\Auth\EmailVerificationRequest  $request
     * @return \Illuminate\Http\RedirectResponse
     */
    public function __invoke(EmailVerificationRequest $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard').'?verified=1');
        }

        if ($request->user()->markEmailAsVerified()) {
            event(new Verified($request->user()));
        }

        return redirect()->intended(route('dashboard').'?verified=1');
    }
}

=== File: AuthenticatedSessionController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;

class AuthenticatedSessionController extends Controller
{
    /**
     * Handle an incoming authentication request.
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'string', 'email'],
            'password' => ['required', 'string'],
        ]);

        $credentials = $request->only('email', 'password');
        $remember = $request->boolean('remember');

        if (Auth::attempt($credentials, $remember)) {
            $request->session()->regenerate();

            // Log successful login
            Log::info('User logged in successfully', ['email' => $request->email]);
            
            return redirect()->intended(route('dashboard'));
        }

        // Log failed login attempt
        Log::info('Failed login attempt', ['email' => $request->email]);

        return back()->withErrors([
            'email' => __('auth.failed'),
        ])->withInput($request->only('email'));
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Auth::guard('web')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}

=== File: EmailVerificationNotificationController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard'));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}

=== File: RegisteredUserController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Providers\RouteServiceProvider;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use Illuminate\View\View;
use App\Models\User;

class RegisteredUserController extends Controller
{
    /**
     * Display the registration view.
     */
    public function create(): View
    {
        return view('auth.register');
    }

    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $validationRules = [
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'string', 'email', 'max:255', 'unique:users'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ];
        
        // Only add terms validation if it's in your form
        if ($request->has('terms')) {
            $validationRules['terms'] = ['required', 'accepted'];
        }
        
        $request->validate($validationRules);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        // Let's automatically log in the user after registration
        Auth::login($user);

        // Add a success message
        session()->flash('success', 'Registration successful! Welcome to PangoQ.');
        
        // Direct to dashboard
        return redirect()->intended(route('dashboard'));
    }
}

=== File: bundled_code.txt ===



=== File: PasswordResetLinkController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;

class PasswordResetLinkController extends Controller
{
    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'email'],
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        return $status == Password::RESET_LINK_SENT
                    ? back()->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

=== File: AuthControllers.php.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Providers\RouteServiceProvider;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use App\Models\User;

class RegisteredUserController extends Controller
{
    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'string', 'email', 'max:255', 'unique:users'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
            'terms' => ['required', 'accepted'],
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        Auth::login($user);

        return redirect(route('dashboard'));
    }
}

class AuthenticatedSessionController extends Controller
{
    /**
     * Handle an incoming authentication request.
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'string', 'email'],
            'password' => ['required', 'string'],
        ]);

        $credentials = $request->only('email', 'password');
        $remember = $request->boolean('remember');

        if (Auth::attempt($credentials, $remember)) {
            $request->session()->regenerate();

            return redirect()->intended(route('dashboard'));
        }

        return back()->withErrors([
            'email' => __('auth.failed'),
        ])->onlyInput('email');
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Auth::guard('web')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard'));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}

class PasswordResetLinkController extends Controller
{
    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'email'],
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        return $status == Password::RESET_LINK_SENT
                    ? back()->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

class NewPasswordController extends Controller
{
    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => ['required'],
            'email' => ['required', 'email'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        return $status == Password::PASSWORD_RESET
                    ? redirect()->route('login')->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

class ConfirmablePasswordController extends Controller
{
    /**
     * Confirm the user's password.
     */
    public function store(Request $request): RedirectResponse
    {
        if (! Auth::guard('web')->validate([
            'email' => $request->user()->email,
            'password' => $request->password,
        ])) {
            throw ValidationException::withMessages([
                'password' => __('auth.password'),
            ]);
        }

        $request->session()->put('auth.password_confirmed_at', time());

        return redirect()->intended(route('dashboard'));
    }
}

=== File: SocialAuthController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Exception;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Session;
use Illuminate\Support\Str;
use Laravel\Socialite\Facades\Socialite;

class SocialAuthController extends Controller
{
    /**
     * Redirect to the given provider's authentication page
     *
     * @param string $provider
     * @return mixed
     */
    public function authProviderRedirect($provider)
    {
        try {
            if (in_array($provider, ['google', 'facebook'])) {
                return Socialite::driver($provider)->redirect();
            }
            return redirect()->route('login')->with('error', 'Invalid authentication provider.');
        } catch (Exception $e) {
            Log::error('Social auth redirect error: ' . $e->getMessage());
            return redirect()->route('login')->with('error', 'Could not connect to ' . ucfirst($provider) . '. Please try again.');
        }
    }

    /**
     * Handle the callback from social authentication providers
     *
     * @param string $provider
     * @return RedirectResponse
     */
    public function socialAuthentication($provider)
    {
        try {
            if (!in_array($provider, ['google', 'facebook'])) {
                return redirect()->route('login')->with('error', 'Invalid authentication provider.');
            }
            
            $socialUser = Socialite::driver($provider)->user();
            
            // Find user by provider ID first
            $user = User::where('auth_provider_id', $socialUser->id)
                        ->where('auth_provider', $provider)
                        ->first();
            
            // If user not found by provider ID, try to find by email
            if (!$user) {
                $user = User::where('email', $socialUser->email)->first();
                
                // If user exists with the same email, update their provider details
                if ($user) {
                    $user->update([
                        'auth_provider' => $provider,
                        'auth_provider_id' => $socialUser->id,
                    ]);
                } else {
                    // Create a new user
                    $user = User::create([
                        'name' => $socialUser->name,
                        'email' => $socialUser->email,
                        'password' => Hash::make(Str::random(24)), // Generate a secure random password
                        'auth_provider_id' => $socialUser->id,
                        'auth_provider' => $provider,
                        'email_verified_at' => now(), // Social logins are considered verified
                    ]);
                    
                    // Save profile photo if available
                    if ($socialUser->avatar) {
                        $user->update([
                            'profile_photo_path' => $socialUser->avatar
                        ]);
                    }
                }
            }
            
            Auth::login($user);
            return redirect()->route('dashboard')->with('success', 'Successfully logged in!');
            
        } catch (Exception $e) {
            Log::error('Social authentication error: ' . $e->getMessage());
            return redirect()->route('login')
                ->with('error', 'Authentication failed. Please try again or use email login.');
        }
    }
}

=== File: ConfirmablePasswordController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Validation\ValidationException;

class ConfirmablePasswordController extends Controller
{
    /**
     * Confirm the user's password.
     */
    public function store(Request $request): RedirectResponse
    {
        if (! Auth::guard('web')->validate([
            'email' => $request->user()->email,
            'password' => $request->password,
        ])) {
            throw ValidationException::withMessages([
                'password' => __('auth.password'),
            ]);
        }

        $request->session()->put('auth.password_confirmed_at', time());

        return redirect()->intended(route('dashboard'));
    }
}

=== File: NewPasswordController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
use Illuminate\Validation\Rules;

class NewPasswordController extends Controller
{
    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => ['required'],
            'email' => ['required', 'email'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        return $status == Password::PASSWORD_RESET
                    ? redirect()->route('login')->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}

=== File: Auth/ConfirmablePasswordController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Validation\ValidationException;

class ConfirmablePasswordController extends Controller
{
    /**
     * Confirm the user's password.
     */
    public function store(Request $request): RedirectResponse
    {
        if (! Auth::guard('web')->validate([
            'email' => $request->user()->email,
            'password' => $request->password,
        ])) {
            throw ValidationException::withMessages([
                'password' => __('auth.password'),
            ]);
        }

        $request->session()->put('auth.password_confirmed_at', time());

        return redirect()->intended(route('dashboard'));
    }
}

=== File: Auth/NewPasswordController.php ===

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
use Illuminate\Validation\Rules;

class NewPasswordController extends Controller
{
    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => ['required'],
            'email' => ['required', 'email'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        return $status == Password::PASSWORD_RESET
                    ? redirect()->route('login')->with('status', __($status))
                    : back()->withInput($request->only('email'))
                            ->withErrors(['email' => __($status)]);
    }
}